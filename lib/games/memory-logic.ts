// ========================================
// MEMORY GAME LOGIC
// ========================================

export interface Card {
  id: number;
  emoji: string;
  isFlipped: boolean;
  isMatched: boolean;
}

export type Difficulty = "easy" | "medium" | "hard";

export interface DifficultyConfig {
  pairs: number;
  cols: number;
  label: string;
}

export const DIFFICULTY_CONFIG: Record<Difficulty, DifficultyConfig> = {
  easy: { pairs: 6, cols: 3, label: "Easy (3Ã—4)" },
  medium: { pairs: 8, cols: 4, label: "Medium (4Ã—4)" },
  hard: { pairs: 10, cols: 5, label: "Hard (5Ã—4)" },
};

const EMOJI_POOL = [
  "ðŸ¶", "ðŸ±", "ðŸ¼", "ðŸ¦Š", "ðŸ¸", "ðŸµ", "ðŸ¦", "ðŸ»",
  "ðŸ§", "ðŸ¢", "ðŸ¦‹", "ðŸ", "ðŸŒ¸", "ðŸŒº", "ðŸŽ", "ðŸŠ",
  "ðŸ‹", "ðŸ‡", "ðŸ’", "ðŸ“",
];

/**
 * Generate a shuffled board of card pairs
 */
export function generateBoard(pairs: number): Card[] {
  const emojis = EMOJI_POOL.slice(0, pairs);
  const cards: Card[] = [];

  emojis.forEach((emoji, i) => {
    cards.push({ id: i * 2, emoji, isFlipped: false, isMatched: false });
    cards.push({ id: i * 2 + 1, emoji, isFlipped: false, isMatched: false });
  });

  // Fisher-Yates shuffle
  for (let i = cards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [cards[i], cards[j]] = [cards[j], cards[i]];
  }

  return cards;
}

/**
 * Check if two cards match
 */
export function checkMatch(card1: Card, card2: Card): boolean {
  return card1.emoji === card2.emoji;
}

/**
 * Check if all pairs have been found
 */
export function isBoardComplete(board: Card[]): boolean {
  return board.every((card) => card.isMatched);
}

/**
 * Calculate score based on moves and time
 * Lower moves + lower time = higher score
 */
export function calculateScore(pairs: number, moves: number, timeSeconds: number): number {
  const perfectMoves = pairs; // minimum possible moves
  const moveScore = Math.max(0, 100 - (moves - perfectMoves) * 5);
  const timeScore = Math.max(0, 100 - timeSeconds);
  return Math.round((moveScore + timeScore) / 2);
}
